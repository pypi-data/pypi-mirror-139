#!/usr/bin/env python3

"""
** Makes the communication medium and its use independent. **
-------------------------------------------------------------

Whether it is tcp sockets, files, mailboxes or a drive like dropbox,
we want to be able to use all these media indifferently...
That's the role of this module.
It allows to add an abstraction layer to unify the communication API.
"""

import abc
import itertools
import socket
import threading
import time
import uuid

from context_verbose import printer as ctp

from raisin.serialization import deserialize, serialize
from raisin.serialization.iter_tools import anticipate, size2tag, tag2size
from raisin.encapsulation.formatting import format_package, unpack_message
from raisin.communication.request import shut_rdwr


__pdoc__ = {
    'AbstractConn.__enter__' : True,
    'AbstractConn.__exit__' : True,
}


class AbstractConn(abc.ABC):
    """
    ** Allows for easier communication. **

    It is the basic abstract class that allows to make information
    carriers of very different nature communicate in the same way.
    """
    @abc.abstractmethod
    def get_conn_identities(self):
        """
        ** Retrieves the names of all accessible connections. **

        Must be overwritten.

        Returns
        -------
        conn_identities : set
            All the identifiers of the recipients that
            can be contacted via the keyword *dest*.
        """
        raise NotImplementedError('this abstract method must be overwritten')

    @abc.abstractmethod
    def send(self, raw, dest=None):
        """
        ** Sends a data stream to the recipient. **

        Must be overwritten.

        Parameters
        ----------
        raw : iterator
            A generator that yields byte strings. The division is arbitrary.
            On reception, the packets received are not necessarily split in the same way.
            This flow can typically be generated by the ``raisin.serialization.serialize`` function.
        dest : default=None
            The identity of the recipient(s) of the message.
            By default (None), the message is sent to the main recipient.

        Raises
        ------
        KeyError
            If the address does not exist.
        ConnectionError
            If the connection is broken.
        """
        raise NotImplementedError('this abstract method must be overwritten')

    def send_obj(self, obj, dest=None, **kwargs):
        """
        ** Sends an object to the recipient. **

        Can be overwritten.

        Parameters
        ----------
        obj
            It is the serialisable object that is sent to the recipient(s).
        dest : default=None
            Same as ``AbstractConn.send``.
        **kwargs : dict
            These are the parameters passed to the ``raisin.serialization.serialize`` function.
        """
        with ctp(f'Send object {repr(obj)}...'):
            self.send(serialize(obj, **kwargs), dest=dest)

    @abc.abstractmethod
    def recv(self, dest=None, *, timeout=None):
        """
        ** Recovers the raw data sent by the sender. **

        Must be overwritten.

        Parameters
        ----------
        dest : default=None
            The identity of the sender of the message.
            By default (None), the message is read to the main connection.
        timeout : number, default=None
            The maximum time allowed to receive all packets
            before the connection is closed.

        Yields
        ------
        bytes
            The packets of bytes emitted by the ``AbstractConn.send``
            method of the sender. Packet decoding may differ, but the order is preserved.
            A negative or null value will raise the exception immediately.

        Raises
        ------
        ConnectionResetError
            If the connection is closed itself.
        ConnectionError
            If the connection is broken.
        KeyError
            If the address does not exist.
        TimeoutError
            If the maximum waiting time is reached.
        """
        raise NotImplementedError('this abstract method must be overwritten')

    def recv_obj(self, dest=None, *, timeout=None, **kwargs):
        """
        ** Recover and deserialize the sent object. **

        Can be overwritten.

        Parameters
        ----------
        dest : default=None
            Same as ``AbstractConn.recv``.
        timeout : number, default=None
            Same as ``AbstractConn.recv``.
        **kwargs : dict
            These are the parameters passed to the ``raisin.serialization.deserialize`` function.

        Returns
        -------
        obj
            The emitted object.
        """
        with ctp('Object reception...'):
            obj = deserialize(self.recv(dest=dest, timeout=timeout), **kwargs)
            ctp.print(f'receved obj: {obj}')
            return obj

    @abc.abstractmethod
    def close(self):
        """
        ** Definitely close the connection. **

        Must be overwritten.
        """
        raise NotImplementedError('this abstract method must be overwritten')

    def __enter__(self):
        """
        ** Allows to manage the closure through a context manager. **
        """
        return self

    def __exit__(self, exc_type, value, traceback):
        """
        ** Guaranteed that the connection closes in all cases. **
        """
        self.close()


class SelectiveConn(AbstractConn):
    """
    ** Allows you to receive a specific message. **

    In particular, this class allows to retrieve a message without losing the others.
    For example if a thread is waiting for a response, the message that is intended
    for it must not be intercepted by another thread.
    This class allows to manage these conflicts.
    """
    def __init__(self):
        self.lock_send = threading.Lock()
        self.lock_recvs = {None: threading.Lock()} # one lock per connection
        self.lock_unpack = threading.Lock()
        self.res_buff = [] # to each signature, associates the received object

    def send_formatted(self, content, kind, signature=None, **kwargs):
        """
        ** Allows you to send information by indicating its nature. **

        For example, it is necessary to be able to separate questions from answers.

        Parameters
        ----------
        content
            Forwarded to ``raisin.encapsulation.formatting.format_package``.
        kind : str
            Forwarded to ``raisin.encapsulation.formatting.format_package``.
        signature : bytes
            Forwarded to ``raisin.encapsulation.formatting.format_package``.
        **kwargs : dict
            The parameters directly transmitted to the ``AbstractConn.send_obj`` method.

        Notes
        -----
        This method is thread-safe because it uses a lock.
        """
        assert isinstance(kind, str)

        with ctp(f'Sending formatted {kind} type...'):
            message = format_package(content, kind, signature)
            with self.lock_send:
                self.send_obj(message, **kwargs)

    def recv_formatted(self, *, kind=None, signature=None, get_context=False, **kwargs):
        """
        ** Receives an object and makes verifications on its content. **

        Parameters
        ----------
        kind : str or set, optional
            Selects only the packages that match this type of packages.
        signature : bytes, optional
            Select only the package with this signature.
        get_context : boolean
            If True, also returns the context, not just the content.
        **kwargs : dict
            The parameters directly transmitted to the ``AbstractConn.recv_obj`` method.

        Returns
        -------
        content
            The content of the package that meets the selection criteria.
        context : namedtuple
            Returns this value only if *get_context* is True.

        Examples
        --------
        >>> import socket
        >>> from raisin.communication.abstraction import SocketConn
        >>> soc1, soc2 = socket.socketpair()
        >>> with SocketConn(soc1) as conn1, SocketConn(soc2) as conn2:
        ...     conn1.send_formatted(0, kind='answer', signature=b'0')
        ...     conn1.send_formatted(1, kind='answer', signature=b'1')
        ...     conn1.send_formatted(2, kind='answer', signature=b'2')
        ...     conn1.send_formatted('a', kind='request')
        ...     conn1.send_formatted('b', kind='request')
        ...     conn2.recv_formatted(signature=b'1')
        ...     conn2.recv_formatted(kind='request')
        ...     conn2.recv_formatted(kind='request', get_context=True)
        ...     conn2.recv_formatted(signature=b'0')
        ...     conn2.recv_formatted(signature=b'2', get_context=True)
        ...
        1
        'a'
        ('b', context(kind='request', signature=None))
        0
        (2, context(kind='answer', signature=b'2'))
        >>>
        """
        assert (
            kind is None
            or isinstance(kind, str)
            or (isinstance(kind, set) and all(isinstance(k, str) for k in kind))
        )
        assert signature is None or isinstance(signature, bytes)
        assert isinstance(get_context, bool)

        if isinstance(kind, str):
            kind = {kind}
        with ctp(
            f'Receiving a {kind} type message{"" if kind is None or len(kind) < 2 else "s"}...'
        ):
            while True:

                if self.res_buff:
                    with ctp('Search among the received messages...'):
                        with self.lock_unpack: # to prevent the self.res_buff from changing
                            for n_pack, (context, content) in enumerate(self.res_buff):
                                if (
                                    (kind is None or context.kind in kind)
                                    and (
                                        signature is None
                                        or context._asdict().get('signature', None) == signature
                                    )
                                ):
                                    ctp.print(f'the message {context} fits')
                                    del self.res_buff[n_pack]
                                    if get_context:
                                        return content, context
                                    return content
                        ctp.print('among the messages already received, none of them fit the bill')

                with ctp('Attempt to appropriate the connection...'):
                    if kwargs.get('dest', None) not in self.lock_recvs:
                        self.lock_recvs[kwargs.get('dest', None)] = threading.Lock()
                    lock_recv = self.lock_recvs[kwargs.get('dest', None)]
                    if lock_recv.locked():
                        time.sleep(0.5)
                        ctp.print('another thread has already taken over the connection')
                        continue
                    ctp.print('we have the exclusivity of the connection')

                with ctp('Recovery of the next result...'):
                    with lock_recv:
                        message = self.recv_obj(**kwargs)
                        with self.lock_unpack:
                            content, context = unpack_message(message)
                            self.res_buff.insert(0, (context, content))

    def dialog(self, request, *, timeout=60, **kwargs):
        """
        ** Send a request and wait for the answer. **

        This method can be called from a thread without any risk
        of interference, because everything is set up to make it work.
        This method is blocking: it waits until the result is available.

        Parameters
        ----------
        request
            The content of the request.
        timeout : number, default=60
            The maximum allowable time (in s) from sending to receiving the message.
            The value *None* allows to skip this limit.
        **kwargs : dict
            The parameters directly transmitted to the ``SelectiveConn.send_formatted``
            and ``SelectiveConn.recv_formatted`` method.

        Returns
        -------
        answer
            The content of the result is linked to the issued request.

        Examples
        --------
        >>> import socket
        >>> from raisin.communication.abstraction import SocketConn
        >>> from raisin.communication.handler import Handler
        >>> soc1, soc2 = socket.socketpair()
        >>> with SocketConn(soc1) as conn, Handler(SocketConn(soc2)) as handler:
        ...     handler.start()
        ...     conn.dialog('hello')
        ...
        'hello'
        >>>
        """
        with ctp(f'Dialog the request {request}...'):
            init_date = time.time()
            signature = uuid.uuid4().bytes
            self.send_formatted(request, kind='request', signature=signature, **kwargs)
            recv_timeout = init_date-time.time()+timeout if timeout is not None else None
            answer = self.recv_formatted(
                kind='answer',
                signature=signature,
                timeout=recv_timeout,
                **kwargs)
            ctp.print(f'the answer: {answer}')
            return answer


class SocketConn(SelectiveConn):
    """
    ** Adds an abstraction layer to TCP sockets. **

    Attributes
    ----------
    conn : socket.socket
        A socket capable of reading and sending data.
    """

    def __init__(self, conn):
        SelectiveConn.__init__(self)
        self.conn = conn
        self._recv_pack = b'' # buffer memory

    def get_conn_identities(self):
        """
        ** Implementation of ``AbstractConn.get_conn_identities``. **
        """
        return {None}

    def send(self, raw, dest=None):
        """
        ** Implementation of ``AbstactConn.send``. **
        """
        if dest is not None:
            raise KeyError('this connection is linked to a single recipient')
        for is_end, pack in anticipate(raw):
            signed_pack = bytes([is_end]) + size2tag(len(pack)) + pack
            try:
                self.conn.sendall(signed_pack)
            except OSError as err:
                raise ConnectionError('communication seems to be interrupted') from err

    def recv(self, dest=None, *, timeout=None):
        """
        ** Implementation of ``AbstraConn.recv``. **
        """
        if dest is not None:
            raise KeyError('this connection is linked to a single recipient')

        def update_timeout(init_date, timeout):
            """ updates the remaining time """
            if timeout is not None:
                remaining_time = init_date - time.time() + timeout
                if remaining_time <= 0:
                    self.conn.settimeout(None)
                    raise TimeoutError('the waiting time at the reception is over')
                self.conn.settimeout(remaining_time)

        def get_pack(init_date, timeout):
            """ get the following package """
            update_timeout(init_date, timeout)
            try:
                data = self.conn.recv(4096)
            except socket.timeout as err:
                self.conn.settimeout(None)
                raise TimeoutError(
                    'the reception is interrupted because the time over'
                ) from err
            except ConnectionResetError as err:
                raise err
            except OSError as err:
                raise ConnectionError('communication seems to be interrupted') from err
            else:
                if not data: # socket closed
                    raise ConnectionResetError(
                        'data received are empty, the socket is probably closed')
                return data

        init_date = time.time()
        while True:
            # check for len and last pack
            if not self._recv_pack:
                self._recv_pack += get_pack(init_date, timeout)
            is_end, self._recv_pack = bool(self._recv_pack[0]), self._recv_pack[1:]
            size, self._recv_pack, _ = tag2size(
                pack=self._recv_pack,
                gen=(get_pack(init_date, timeout) for _ in itertools.count(0))
            )
            while len(self._recv_pack) < size:
                self._recv_pack += get_pack(init_date, timeout)
            yield self._recv_pack[:size]
            self._recv_pack = self._recv_pack[size:]
            if is_end:
                try:
                    self.conn.settimeout(None)
                except OSError:
                    pass
                break

    def close(self):
        """
        ** Implementation of ``AbstractConn.close``. **

        Notes
        -----
        Do not use *socket.close* because it causes unwanted problems for the peer.
        """
        shut_rdwr(self)
        try:
            self.conn.shutdown(socket.SHUT_RDWR)
        except OSError:
            pass


class BridgeConn(SelectiveConn):
    """
    ** Allows one connection to reach others. **

    Attributes
    ----------
    main_conn : AbstractConn
        The main connection, the one that is intended
        when the target is not specified.
    other_conn : dict
        To each connection name, associate the connection.
    """

    def __init__(self, main_conn, other_conn):
        SelectiveConn.__init__(self)
        self.main_conn = main_conn
        self.other_conn = other_conn

    def get_conn_identities(self):
        """
        ** Implementation of ``AbstractConn.get_conn_identities``. **
        """
        return {None} | set(self.other_conn)

    def send(self, raw, dest=None):
        """
        ** Implementation of ``AbstactConn.send``. **
        """
        if dest is None:
            return self.main_conn.send(raw)
        try:
            return self.other_conn[dest].send(raw)
        except KeyError as err:
            raise KeyError(
                f"only the recipients {list(self.other_conn.keys())} exist, not '{dest}'"
            ) from err

    def recv(self, dest=None, *, timeout=None):
        """
        ** Implementation of ``AbstraConn.recv``. **
        """
        if dest is None:
            yield from self.main_conn.recv(timeout=timeout)
        elif dest in self.other_conn:
            yield from self.other_conn[dest].recv(timeout=timeout)
        else:
            raise KeyError(
                f"only the recipients {list(self.other_conn)} exist, not '{dest}'"
            )

    def close(self):
        """
        ** Implementation of ``AbstractConn.close``. **
        """
        self.main_conn.close()
        for conn in self.other_conn.values():
            conn.close()


class ServerConn(SelectiveConn):
    """
    ** Allows you to bridge the gap between clients. **

    The 'server' class inherits from this class.
    Thus, it is possible to make the different clients connected
    to the same server communicate with each other.

    Attributes
    ----------
    clients_conn : dict
        To each client identifier, associates the connection of this client.
    """

    def __init__(self):
        SelectiveConn.__init__(self)
        self.clients_conn = {}

    def _conn_expansion(self, abstract_conn, client_id):
        """
        ** Memorizes and expands a connection. **

        The server calls this method when the handler is created.
        This is to extend the *abstract_conn* connection so that
        the handler can have access to other clients.

        Parameters
        ----------
        abstract_conn : AbstractConn
            A simple and minimalist connection that
            allows you to get in touch with a single client.
        client_id
            Unique identifier that characterizes the client.

        Returns
        -------
        extended_abstract_conn : AbstractConn
            A connection that allows of course to continue to communicate with the customers.
            That is, it has a similar behavior to the *abstract_conn* argument,
            but it also allows to address the connections of other clients.
        """
        self.clients_conn[client_id] = abstract_conn
        return BridgeConn(main_conn=abstract_conn, other_conn=self.clients_conn)

    def get_conn_identities(self):
        """
        ** Implementation of ``AbstractConn.get_conn_identities``. **

        Examples
        --------

        """
        return set(self.clients_conn)

    def send(self, raw, dest=None):
        """
        ** Implementation of ``AbstactConn.send``. **
        """
        if dest is None:
            raise KeyError(
                'there is no default receiver, you have to specify: '
                f'{list(self.clients_conn)}'
            )
        try:
            return self.clients_conn[dest].send(raw)
        except KeyError as err:
            raise KeyError(
                f"only the recipients {list(self.clients_conn)} exist, not '{dest}'"
            ) from err

    def recv(self, dest=None, *, timeout=None):
        """
        ** Implementation of ``AbstraConn.recv``. **
        """
        if dest is None:
            raise KeyError(
                'there is no default receiver, you have to specify: '
                f'{list(self.clients_conn.keys())}'
            )
        if dest not in self.clients_conn:
            raise KeyError(
                f"only the recipients {list(self.clients_conn)} exist, not '{dest}'"
            )
        yield from self.clients_conn[dest].recv(timeout=timeout)

    def close(self):
        """
        ** Implementation of ``AbstractConn.close``. **
        """
        for conn in self.clients_conn.values():
            conn.close()
