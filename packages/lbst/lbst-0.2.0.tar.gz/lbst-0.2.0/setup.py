# -*- coding: utf-8 -*-
from setuptools import setup

modules = \
['lbst']
setup_kwargs = {
    'name': 'lbst',
    'version': '0.2.0',
    'description': 'Immutable Log-Balanced Search Tree',
    'long_description': '# lbst - Immutable Log-Balanced Search Tree\n\n**prototype:** With CPython, in so far, it is faster to use LBST with\n1000+ items. wall-clock time benchmarks show that this datastructure\nbecomes interesting with PyPy 3.7 with 100+ items.\n\n![pink sakura tree at daytime](https://images.unsplash.com/photo-1515863149848-223cbed59017?w=1024&q=80)\n\n## Benchmarks\n\nHigher is better, less than one means copying is faster.\n\n### Small number of items = 20\n\n```\ncpython: ▇▇▇▇▇▇▇ 0.039\npypy   : ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 0.262\n```\n\n### Large number of items = 1000\n\n```\ncpython: ▇▇ 0.9489\npypy   : ▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇▇ 20.15\n```\n\n## Kesako a Log-Balanced Search Tree?\n\n- A search tree is a dictionary that preserves ordering according to\n  an user specified function, also known under the name sorted\n  dictionary.\n  \n- In the original description of the algorithm, LBST used a logarithm\n  function to decide how to balance the tree.\n\n## Kesako an immutable datastructure?\n\nImmutable datastructures, also known under the name *persistent\ndatastructures* are datastructures that will produce new values\ninstead of changing, mutating, the value in-place.\n\nImmutable datastructures are useful in situations where you need to\nkeep around previous versions of the data to have an history to ease\ndebugging or to implement an *undo* feature such as in editors;\nanother way immutable datastructures can be put to good use is to keep\nthe data consistent in a concurrent or parallel programming setting,\nwhile a flow of executition, the writer, produce a new version of the\ndatastructure, the readers still have access the previous version of\nthe truth without requiring readers to wait for the writer to finish\nachieving single-writer / multiple readers without locks.\n\n## When is an immutable datastructure useful?\n\nAnytime you copy a *big* data structure, you may instead use an\nimmutable datastructure.\n\n## What is the difference with `dict` insertion order?\n\nPython builtin `dict` are sorted according to the time of insertion,\nif `"z"` is added to a dictionary first, then `"a"` is added, then the\ndictionary will have the keys in the following order `["z", ...,\n"a"]`. That is not always the best approach performance-wise.\n\nThe following kind of code is a hint that you may use LBST:\n\n```python\nfrob = dict()\nfrob[key1] = value1\nfrob[key2] = value2\nfrob[key3] = value3\n...\n\n# then re-create the dictionary with an order given by `mykeyfunc`:\nfrob = {k: v for k in sorted(frob.keys(), key=mykeyfunc)\n```\n\nThat is somekind of copy, see the previous hint, that re-orders the\ndictionary keys according to `mykeyfunc` in order for instance to\nspeed up linear lookup. Using LBST, you can build a **large**\ndictionary that is sorted at construction time, save a few cycles by\navoding a reconstruction, duplicated effort, copies, and keep the\noverall wall-clock time under control.\n\n## `lbst.make()`\n\nReturn an immutable search tree, ordered according to Python builtin\nrich comparison, that can be overriden in user created types with the\nmethod called\n[`__lt__`](https://docs.python.org/3/reference/datamodel.html#object.__lt__).\n\n## `lbst.set(tree, key, value)`\n\nReturn a tree based on `tree` where `key` is associated with\n`value`.\n\n## `lbst.get(tree, key, default=None)`\n\nReturn the value associated with `key` in `tree`. If `key` is not\npresent in `tree`, returns `default`.\n\n## `lbst.delete(tree, key)`\n\nReturn a tree based on `tree` where `key` is not present.\n\n## `lbst.size(tree)`\n\nReturn the size of `tree`.\n\n## `lbst.start(tree)`\n\nReturn the smallest key present in `tree`.\n\n## `lbst.end(tree)`\n\nReturn the biggest key present in `tree`.\n\n## `lbst.cursor(tree)`\n\nReturn a cursor for `tree`. The initial position is not specified. A\ncursor is stateful: its position is changed / mutated in-place.\n\n## `lbst.cursor_clone(cursor)`\n\nReturn a cursor at the same position as `cursor` that does not share\nstate with `cursor`.\n\n## `lbst.cursor_seek(cursor, key)`\n\nPosition `cursor` near `key`. If `key` is present in the tree\nassociated with `cursor`, then the cursor will be exactly positioned\non `key` and `lbst.cursor_seek` will return `0`. Otherwise, when `key`\nis not present in the tree associated with `cursor`, there is two\ncases: 1) if the cursor is positioned after, then `lbst.cursor_seek`\nreturns `1`, and 2) if the cursor is positioned before, then\n`lbst.cursor_seek` return `-1`.\n\nIn other words, `lbst.cursor_seek`:\n\n- Return `-1`, then `cursor` is before `key`;\n- Return `0`, then `cursor` is **on** `key`;\n- Return `1`, then `cursor` is after `key`.\n\n## `lbst.cursor_key(cursor)`\n\nReturn the key associated with `cursor`.\n\n## `lbst.cursor_value(cursor)`\n\nReturn the value associated with `cursor`.\n\n## `lbst.cursor_next(cursor)`\n\nMove `cursor` to the next position, that is a bigger key that is just\nafter the current key. Returns `False` if `cursor` reached the end of\nthe key space *i.e.* there is no next key. Otherwise, it returns\n`True`.\n\n## `lbst.cursor_previous(cursor)`\n\nMove `cursor` to the previous position, that is a smaller key that is\njust before the current key. Returns `False` if `cursor` reached the start of\nthe key space *i.e.* there is no previous key. Otherwise, it returns\n`True`.\n\n## `lbst.to_dict(tree)`\n\nReturn a `dict` representation of `tree`. The returned `dict` has the\nkeys in the same order as `tree`.\n',
    'author': 'Amirouche',
    'author_email': 'amirouche@hyper.dev',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/amirouche/lbst',
    'py_modules': modules,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
