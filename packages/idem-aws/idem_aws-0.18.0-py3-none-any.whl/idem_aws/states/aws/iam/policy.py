"""
Autogenerated using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.iam.create_policy
hub.exec.boto3.client.iam.delete_policy
hub.exec.boto3.client.iam.get_policy
hub.exec.boto3.client.iam.list_policies
hub.exec.boto3.client.iam.tag_policy
hub.exec.boto3.client.iam.untag_policy
resource = hub.tool.boto3.resource.create(ctx, "iam", "Policy", name)
hub.tool.boto3.resource.exec(resource, attach_group, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, attach_role, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, attach_user, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, create_version, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, delete, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, detach_group, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, detach_role, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, detach_user, *args, **kwargs)
"""
import json
from collections import OrderedDict
from typing import Any
from typing import Dict
from typing import List

__contracts__ = ["resource"]


async def present(
    hub,
    ctx,
    name: str,
    policy_name: str,
    policy_document: Dict or str,
    path: str = "/",
    description: str = None,
    tags: List = None,
) -> Dict[str, Any]:
    r"""
    **Autogenerated function**

    Create or update a managed policy for your Amazon Web Services account. When creating a policy, this operation
     creates a policy version with a version identifier of v1 and sets v1 as the policy's default version. When updating
      a policy, this operation creates a new policy version, sets the new policy to the default version, and
       deletes the old policy. As a best practice, you can validate your IAM policies. To learn more, see Validating
        IAM policies in AWS's IAM User Guide. For more information about managed policies in general,
         see Managed policies and inline policies in AWS's IAM User Guide.

    Args:
        name(Text): A name, or the Amazon Resource Name (ARN) to identify the resource.
        policy_name(Text): The friendly name of the policy. Policy names must be unique within the account.
         They are not distinguished by case.
        policy_document(Dict or Text): The JSON policy document that you want to use as the content for the new policy.
         You must provide policies in JSON format in IAM. However, for CloudFormation templates formatted in YAML,
          you can provide the policy in JSON or YAML format. CloudFormation always converts a YAML policy to JSON format
           before submitting it to IAM.
        path(Text, Optional): The path for the policy. Defaults to a slash (/)
        description(Text, Optional): A friendly description of the policy.
        tags(List, Optional): A list of tags that you want to attach to the new IAM customer managed policy.
         Each tag consists of a key name and an associated value.

    Request Syntax:
        [policy-resource-id]:
          aws.iam.policy.present:
          - policy_name: 'string'
          - path: 'string'
          - policy_document: 'dict' or 'string'
          - description: 'string'
          - tags:
            - Key: 'string'
              Value: 'string'

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            arn:aws:iam::53721234567:policy/idem-policy-automation:
              aws.iam.policy.present:
                - policy_name: idem-policy-automation
                - path: /
                - policy_document: '{"Statement": [{"Action": ["ec2:CreateSubnet"], "Effect": "Allow", "Resource": "*"}], "Version": "2012-10-17"}'
                - description: "Idem IAM policy description example"
                - tags:
                  - Key: Name
                    Value: Idem-test-policy
    """

    result = dict(comment="", old_state=None, new_state=None, name=name, result=True)
    resource = hub.tool.boto3.resource.create(ctx, "iam", "Policy", name)
    before = await hub.tool.boto3.resource.describe(resource)
    if ctx.get("test", False):
        if before:
            result["comment"] = f"Would update aws.iam.policy {name}"
            result["result"] = True
        else:
            result["comment"] = f"Would create aws.iam.policy {name}"
            result["result"] = True
        return result
    policy_document = (
        policy_document
        if isinstance(policy_document, str)
        else json.dumps(policy_document)
    )

    if before:
        try:
            before.pop("ResponseMetadata", None)
            result["old_state"] = before
            result["comment"] = f"'{name}' already exists"
            # Update policy document
            update_ret = await hub.exec.aws.iam.policy.update_policy(
                ctx=ctx,
                policy_arn=before.get("Arn"),
                policy_version_id=before.get("DefaultVersionId"),
                new_policy_document=policy_document,
            )
            if not update_ret["result"]:
                result["comment"] = update_ret["comment"]
                result["result"] = False
            # Update policy tags
            if tags is not None:
                update_ret = await hub.exec.aws.iam.policy.update_policy_tags(
                    ctx=ctx,
                    police_arn=before.get("Arn"),
                    old_tags=before.get("Tags"),
                    new_tags=tags,
                )
                if not update_ret["result"]:
                    result["comment"] = result["comment"] + " " + update_ret["comment"]
                    result["result"] = False
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"
            result["result"] = False
        if result["result"]:
            result["comment"] = f"'Update {name}'"
    else:
        try:
            ret = await hub.exec.boto3.client.iam.create_policy(
                ctx,
                PolicyName=policy_name,
                Path=path,
                PolicyDocument=policy_document,
                Description=description,
                Tags=tags,
            )
            result["result"] = ret["result"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Created '{name}'"
            resource = hub.tool.boto3.resource.create(
                ctx, "iam", "Policy", ret["ret"]["Policy"]["Arn"]
            )
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"
            result["result"] = False

    try:
        after = await hub.tool.boto3.resource.describe(resource)
        after.pop("ResponseMetadata", None)
        result["new_state"] = after
    except Exception as e:
        result["comment"] = str(e)
        result["result"] = False
    return result


async def absent(hub, ctx, name: str) -> Dict[str, Any]:
    r"""
    **Autogenerated function**

    Deletes the specified managed policy. Before you can delete a managed policy, you must first detach the policy
    from all users, groups, and roles that it is attached to. In addition, you must delete all the policy's
    versions. The following steps describe the process for deleting a managed policy:   Detach the policy from all
    users, groups, and roles that the policy is attached to, using DetachUserPolicy, DetachGroupPolicy, or
    DetachRolePolicy. To list all the users, groups, and roles that a policy is attached to, use
    ListEntitiesForPolicy.   Delete all versions of the policy using DeletePolicyVersion. To list the policy's
    versions, use ListPolicyVersions. You cannot use DeletePolicyVersion to delete the version that is marked as the
    default version. You delete the policy's default version in the next step of the process.   Delete the policy
    (this automatically deletes the policy's default version) using this operation.   For information about managed
    policies, see Managed policies and inline policies in the IAM User Guide.

    Args:
        name(Text): A name, or the Amazon Resource Name (ARN) to identify the resource.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws.iam.policy.absent:
                - name: value
    """

    result = dict(comment="", old_state=None, new_state=None, name=name, result=True)
    resource = hub.tool.boto3.resource.create(ctx, "iam", "Policy", name)
    before = await hub.tool.boto3.resource.describe(resource)

    if not before:
        result["comment"] = f"'{name}' already absent"
    elif ctx.get("test", False):
        result["comment"] = f"Would delete aws.iam.policy {name}"
        return result
    else:
        try:
            before.pop("ResponseMetadata", None)
            result["old_state"] = before
            ret = await hub.exec.boto3.client.iam.delete_policy(ctx, PolicyArn=name)
            result["result"] = ret["result"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                result["result"] = False
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    return result


async def describe(hub, ctx) -> Dict[str, Dict[str, Any]]:
    r"""
    **Autogenerated function**

    Describe the resource in a way that can be recreated/managed with the corresponding "present" function


    Lists all of your own customer-defined managed policies.


    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: bash

            $ idem describe aws.iam.policy
    """

    result = {}
    # Set scope to local to only list the customer-defined managed policies.
    ret_policies = await hub.exec.boto3.client.iam.list_policies(ctx, Scope="Local")

    if not ret_policies["result"]:
        hub.log.debug(f"Could not describe policy {ret_policies['comment']}")
        return {}
    describe_parameters = OrderedDict(
        {
            "PolicyName": "policy_name",
            "Path": "path",
            "Description": "description",
        }
    )
    for policy in ret_policies["ret"]["Policies"]:
        policy_arn = policy.get("Arn")
        policy_version_id = policy.get("DefaultVersionId")
        ret_get = await hub.exec.boto3.client.iam.get_policy(ctx, PolicyArn=policy_arn)
        if not ret_get["result"]:
            hub.log.warning(
                f"Failed on fetching policy with arn {policy_arn} with error {ret_get['comment']}."
                f" Describe will skip this policy and continue."
            )
            continue
        resource = ret_get["ret"]["Policy"]
        ret_get_version = await hub.exec.boto3.client.iam.get_policy_version(
            ctx, PolicyArn=policy_arn, VersionId=policy_version_id
        )
        if not ret_get_version["result"]:
            hub.log.warning(
                f"Failed on fetching policy document with arn {policy_arn} and version {policy_version_id} "
                f"with error {ret_get_version['comment']} Describe will skip this policy and continue."
            )
            continue
        document = json.dumps(ret_get_version["ret"]["PolicyVersion"].get("Document"))
        resource_translated = list()
        for parameter_old_key, parameter_new_key in describe_parameters.items():
            if resource.get(parameter_old_key) is not None:
                resource_translated.append(
                    {parameter_new_key: resource.get(parameter_old_key)}
                )
        if resource.get("Tags"):
            resource_translated.append({"tags": resource.get("Tags")})
        resource_translated.append({"policy_document": document})
        result[policy_arn] = {"aws.iam.policy.present": resource_translated}

    return result
